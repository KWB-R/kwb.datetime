---
title: "Converting Text to Time Objects"
author: "Hauke Sonnenberg"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Text to Time Objects}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

print_times <- function(x) {
  old_pars <- par(mar = c(2.5, 4.5, 0.5, 0.5))
  plot(x, seq_along(x), las = 1, xlab = "", ylab = "Index", ylim = c(length(x) + 0.4, 0.6))
  par(old_pars)
}
```

This tutorial describes how to convert text timestamps to `POSIXct` objects. The
conversion becomes necessary when time differences are to be calculated. We
treat two use cases in both of which timestamps were written by a measurement
device. The cases differ in the way the device was operating its clock:

- Case 1: the clock switches between standard (winter) time and summer time.
- Case 2: the clock does not switch between standard (winter) time and summer 
time but always stays in standard time. 

## Creation of example timestamps

We start by creating text timestamps as they could have been recorded by a
measurement device.

```{r}
# Define first and last timestamps
from <- "2019-01-01"
to <- "2020-01-01"
step <- 3600 # seconds, i.e. one timestamp per hour

# Case 1: local time, i.e. standard time in winter, summer time in summer
tz <- "Europe/Berlin"
times_local <- seq(as.POSIXct(from, tz), as.POSIXct(to, tz), by = step)

# Case 2: always standard time (Note that GMT-1 refers to UTC+1!)
tz <- "Etc/GMT-1"
times_standard <- seq(as.POSIXct(from, tz), as.POSIXct(to, tz), by = step)
```

We use `format()` to simulate that the timestamps were written in a certain 
local format:

```{r}
format <- "%d.%m.%y %H:%M"
timestamps_local <- format(times_local, format = format)
timestamps_standard <- format(times_standard, format = format)
```

Show the first three timestamps in each case:

```{r}
writeLines(head(timestamps_local, 3))
writeLines(head(timestamps_standard, 3))
```

## Case 1: Clock switches between standard time and summer time

In this case, it is not enough to run the function `as.POSIXct()` on the 
timestamps, even though the time zone and the format are set correctly:

```{r}
times <- as.POSIXct(timestamps_local, tz = "Europe/Berlin", format = format)
```

### Problem

What is the problem? We can understand the problem when looking at the time
differences:

```{r}
table(diff(times))
```
Not all time differences are one hour (3600 seconds) anymore! Read further down 
for the reason and for a function allowing to further investigate the problem.

### Solution

The package kwb.datetime provides a function that can handle the case correctly
(see below for details). It requires the timestamps to be given in ISO-format,
i.e. in "yyyy-mm-dd HH:MM:SS".

```{r}
# Format the local timestamps to timestamps in ISO format
iso <- kwb.datetime::reformatTimestamp(timestamps_local, old.format = format)

# Convert text timestamps to POSIXct objects
times_local_from_text <- kwb.datetime::berlin_local_timestamps_to_POSIXct(iso)

# Set the time zone (do not rely on tz = "" representing "Europe/Berlin")
attr(times_local_from_text, "tzone") <- "Europe/Berlin"
```

The created `POSIXct`-objects are now identical to the original ones:

```{r}
identical(times_local, times_local_from_text)
```

## Case 2: Clock always stays in standard time

In this case it is enough to set the time zone and the format correctly when
calling `as.POSIXct()`:

```{r}
# Convert text timestamps to POSIXct objects
times_standard_from_text <- as.POSIXct(
  timestamps_standard, tz = "Etc/GMT-1", format = format
)
```

The created `POSIXct`-objects are now identical to the original ones:

```{r}
identical(times_standard, times_standard_from_text)
```

See vignette ["Exkurs Zeitzonen"](timezones.html) for details on this case.

# Background

In R, time information are stored in objects of class `POSIXct`. The function
`as.POSIXct()` is used to convert character strings representing points in time
into the corresponding `POSIXct` objects. This chapter points out some important
details about this function.

Problems may arise with times recorded in time zones that change for Daylight
Saving. This is the case for the time zone "Europe/Berlin" that is used in the
following example. In this time zone, the time is given in Central European
Time (CET) in winter and in Central European Summer Time (CEST) in summer.

## When does Summer Time start/end?

Use the function `date_range_CEST()` to find out at what days summer time starts
and ends, respectively:

```{r}
kwb.datetime::date_range_CEST(2017:2019)
```

Note that this function returns character strings and not, for example, `Date`
objects.

## Example: Reading local timestamps in Berlin, Germany

Imagine a measuring device taking measurements every 30 minutes at some location
in Berlin, Germany. The clock of the device is configured to switch between
standard time and daylight saving time (summer time) and vice versa. In 2017, on
October 29, when summer time is reverted back to standard time, the recorded
timestamps around the time shift are:

```{r}
# Define timestamps (character)
timestamps <- c(
  "2017-10-29 01:30:00", # 1: CEST
  "2017-10-29 02:00:00", # 2: CEST
  "2017-10-29 02:30:00", # 3: CEST
  "2017-10-29 02:00:00", # 4: CET
  "2017-10-29 02:30:00", # 5: CET
  "2017-10-29 03:00:00"  # 6: CET
)
```

The timestamps "02:00" and "02:30" appear twice, at indices 2 and 3,
respectively, first and at indices 4 and 5, respectively, second. This is
because at 03:00 (CEST) the clock is set back to 02:00 (CET). The first
occurrences of the two timestamps refer to summer time (CEST) whereas the second
occurrences refer to standard time (CET).

### What is the problem?

What happens if we convert these timestamps to time objects? Using 
`as.POSIXct()` and the (correct) time zone "Europe/Berlin", we get the following
vector of time objects:

```{r}
# Convert timestamps to POSIXct and print them
(times <- as.POSIXct(timestamps, tz = "Europe/Berlin"))
``` 
The function cannot distinguish between the first and second occurrences of the
times 02:00 and  02:30. The output and the following plot reveal that the
timestamps between 02:00 and 03:00 (exclusive) are always interpreted as being
in summer time (CEST).

```{r fig.width = 5, fig.height = 2, echo = FALSE}
print_times(times)
```

### What is the solution (step by step)?

How can we tell R that the first occurrences of 02:00 and 02:30 refer to CEST
and the second ocurrences refer to CET? We could try the following:

```{r}
as.POSIXct(tz = "Europe/Berlin", c(
  "2017-10-29 01:30:00 CEST",
  "2017-10-29 02:00:00 CEST",
  "2017-10-29 02:30:00 CEST",
  "2017-10-29 02:00:00 CET",
  "2017-10-29 02:30:00 CET",
  "2017-10-29 03:00:00 CET"
))
```

**Unfortunately, this does not work!** Again, everything between 02:00 and 03:00
(exclusive) is assumed to refer to CEST, as the output above indicates. However,
R accepts a format in which the number of hours ahead of Coordinated Universal
Time (UTC) is indicated in the timestamps. In our example this looks as follows:

```{r}
iso_timestamps <- c(
  "2017-10-29 01:30:00+0200",
  "2017-10-29 02:00:00+0200",
  "2017-10-29 02:30:00+0200",
  "2017-10-29 02:00:00+0100",
  "2017-10-29 02:30:00+0100",
  "2017-10-29 03:00:00+0100"
)
```

Timestamps in CEST are two hours (and zero minutes) ahead of UTC. This is 
indicated in the timestamp by the ending *+0200*. Timestamps in CET are only one 
hour ahead of UTC and thus indicated by *+0100*. Timestamps given in this format 
can be converted to POSIXct objects by setting the `format` argument of the 
`as.POSIXct()` function to `"%F %T%z"`:

```{r}
as.POSIXct(iso_timestamps, tz = "Europe/Berlin", format = "%F %T%z")
```

For the meaning of the placeholders %F, %T and %z, respectively, in the
format string, see `?strftime`. 

The package kwb.datetime provides a function `iso_to_localtime()` that does
the same:

```{r}
kwb.datetime::iso_to_localtime(iso_timestamps)
```

In both cases, the timestamps are interpreted correctly, as also shown in this 
plot:

```{r fig.width = 5, fig.height = 2, echo = FALSE}
out <- capture.output(
  print_times(kwb.datetime::iso_to_localtime(iso_timestamps))
)
```

Unfortunately, the timestamps logged by measuring devices often do not contain
the additional information on the UTC offset. For this case the package
kwb.datetime provides three functions that can be applied in a chain to perform
a three step process:

**Step 1:** Use the function `utc_offset_Berlin_time()` to determine the UTC 
offsets (for timestamps given in time zone "Europe/Berlin"):

```{r}
# Guess and print the UTC offsets for the given timestamps
(offsets <- kwb.datetime::utc_offset_Berlin_time(timestamps))
```

This function requires the timestamps to be sorted in increasing order. 
Otherwise it cannot decide between CEST and CET for possibly unambiguous 
timestamps between 02:00 and 03:00 at the day of reverting time from CEST back
to CET.

**Step 2:** Use these offsets and the function `append_utc_offset_string()` to 
create timestamps in ISO 8601 format, i.e. ending in either *+0200* (when 
referring to CEST) or in *+0100* (when referring to CET):

```{r}
# Create ISO 8601 timestamps and print them
(iso_timestamps <- kwb.datetime::append_utc_offset_string(timestamps, offsets))
```

**Step 3:** Use the function `iso_to_localtime()` to convert these new 
timestamps from `character` into their corresponding `POSIXct` objects:

```{r}
# Create POSIXct-objects in time zone "Europe/Berlin" and print them
(kwb.datetime:::iso_to_localtime(iso_timestamps))
```

### What is the solution (one step)?

The three steps presented above are performed in the function
`berlin_local_timestamps_to_POSIXct()` so that you can do the conversion of the
original `timestamps` by calling:

```{r}
kwb.datetime::berlin_local_timestamps_to_POSIXct(timestamps)
```

## Analyse a sequence of POSIXct objects

The package contains a function `getEqualStepRanges()` that helps find
unexpected changes in the time step within a vector of `POSIXct`. Applied to the
example vector `times_local` from above, this function finds exactly one
consistent sequence of times in which the time step is constantly one hour:

```{r}
kwb.datetime::getEqualStepRanges(times_local)
```

As already shown above, using `as.POSIXct()` directly on the vector of text
timestamps does not return the correct `times`. Using `getEqualStepRanges()`
helps understand the problem. It shows four different sub-sequences within 
`times` in each of which the time step differs from the time step in the 
previous sub-sequence.

```{r}
bad_times <- as.POSIXct(timestamps_local, tz = "Europe/Berlin", format = format)
kwb.datetime::getEqualStepRanges(times)
```

What happened? The timestamp `2019-10-27 02:00` appears twice! Once in Central
European Summer Time (CEST) and once in Central European Time (CET). As shown
above, using the function `berlin_local_timestamps_to_POSIXct()` can solve the
problem:

```{r}
# Reformat the timestamps to ISO format
iso <- kwb.datetime::reformatTimestamp(timestamps_local, format)

# Convert to POSIXct
good_times <- kwb.datetime::berlin_local_timestamps_to_POSIXct(iso)

# Show the contained sub-sequences (should be only one now!)
kwb.datetime::getEqualStepRanges(good_times)
```

Check if the original date and time objects could be reproduced:

```{r}
# Explicitly set the time zone before comparing
attr(good_times, "tzone") <- "Europe/Berlin"

identical(good_times, times_local)
```
